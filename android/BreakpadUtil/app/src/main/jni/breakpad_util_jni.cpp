/* DO NOT EDIT THIS FILE - it is machine generated */
#ifndef _Included_com_gotye_thirdparty_BreakpadUtil
#define _Included_com_gotye_thirdparty_BreakpadUtil

#include <jni.h>
/* Header for class com_gotye_thirdparty_BreakpadUtil */

#include <stdio.h>
#include <android/log.h>

#include "client/linux/handler/exception_handler.h"
#include "client/linux/handler/minidump_descriptor.h"

#define LOG_TAG "breakpad_util_jni"
#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)
#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)

#ifdef __cplusplus
extern "C" {
#endif

static google_breakpad::ExceptionHandler *handler = NULL;  

namespace {

bool DumpCallback(const google_breakpad::MinidumpDescriptor& descriptor,
                  void* context,
                  bool succeeded)
{
	LOGE("breakpad catch crash, dump path: %s", descriptor.path());
	return succeeded;
}

void Crash() {
  volatile int* a = reinterpret_cast<volatile int*>(NULL);
  *a = 1;
}

}  // namespace

/*
 * Class:     com_gotye_thirdparty_BreakpadUtil
 * Method:    nativeRegisterBreakpad
 * Signature: (Ljava/lang/String;)Z
 */
JNIEXPORT jboolean JNICALL Java_com_gotye_thirdparty_BreakpadUtil_nativeRegisterBreakpad
  (JNIEnv* env, jclass thiz, jstring dump_folder)
{
	LOGI("nativeRegisterBreakpad()");
	
	char str_path[1024] = {0};
	
	const char *nativeString = env->GetStringUTFChars(dump_folder, 0);
	LOGI("nativeRegisterBreakpad path: %s", nativeString);
	
	// Creates a new ExceptionHandler instance to handle writing minidumps.
	  // Before writing a minidump, the optional |filter| callback will be called.
	  // Its return value determines whether or not Breakpad should write a
	  // minidump.  The minidump content will be written to the file path or file
	  // descriptor from |descriptor|, and the optional |callback| is called after
	  // writing the dump file, as described above.
	  // If install_handler is true, then a minidump will be written whenever
	  // an unhandled exception occurs.  If it is false, minidumps will only
	  // be written when WriteMinidump is called.
	  // If |server_fd| is valid, the minidump is generated out-of-process.  If it
	  // is -1, in-process generation will always be used.
	google_breakpad::MinidumpDescriptor descriptor(nativeString);
	handler = new google_breakpad::ExceptionHandler(descriptor, NULL, DumpCallback,
                                       NULL, true, -1);
									   
	env->ReleaseStringUTFChars(dump_folder, nativeString);
	return JNI_TRUE;  
}

/*
 * Class:     com_gotye_thirdparty_BreakpadUtil
 * Method:    nativeUnregisterBreakpad
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_com_gotye_thirdparty_BreakpadUtil_nativeUnregisterBreakpad()
{
	LOGI("nativeUnregisterBreakpad()");
	
	if (handler != NULL) {
		delete handler;
		handler = NULL;
	}
}

/*
 * Class:     com_gotye_thirdparty_BreakpadUtil
 * Method:    nativeTest
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_com_gotye_thirdparty_BreakpadUtil_nativeTest()
{
	LOGI("nativeTest()");
	
	Crash();
}

#ifdef __cplusplus
}
#endif
#endif
